# Implementation Guide: Redmine-Jira Bi-Directional Integration

**Publication Date:** 2025-10-21

This document provides a comprehensive, actionable implementation guide for the custom-built Redmine-Jira bi-directional integration solution. It is designed to serve as the definitive technical reference for system administrators and developers responsible for deploying, configuring, and maintaining the integration. The guide synthesizes detailed architectural research, API analysis, and application-specific instructions into a cohesive, practical manual. The target audience is technical staff with a moderate to advanced understanding of web applications, REST APIs, system administration, and the Laravel framework.

## ARCHITECTURE ANALYSIS

The architectural foundation of this custom integration solution is a hybrid event-driven model, designed as an external, intermediary service that orchestrates data flow between Redmine and Jira. This approach is heavily influenced by the robust, plugin-free architecture of commercial platforms like OpsHub Integration Manager (OIM). OIM serves as an effective reference model, demonstrating how a centralized integration hub can facilitate high-fidelity, bi-directional data synchronization without installing intrusive plugins into the core Redmine or Jira applications. This decoupling strategy is paramount, as it mitigates common risks associated with plugins, including performance degradation, version compatibility conflicts during system upgrades, and increased administrative overhead. Our custom Laravel solution adopts this philosophy by operating as a standalone microservice, communicating with both Redmine and Jira exclusively through their official REST APIs. This ensures that the integration logic remains isolated, making the entire system more resilient, scalable, and maintainable.

The core of our custom solution's architecture is its reliance on a hybrid approach to real-time event handling. For Jira, the system leverages the platform's robust, native webhook capabilities. Webhooks provide an efficient, push-based mechanism where Jira actively notifies the integration service in near real-time whenever a relevant event occurs, such as the creation or update of an issue. This event-driven pattern is vastly superior to traditional API polling, as it minimizes latency and reduces unnecessary server load. However, the core Redmine application lacks native webhook support, presenting a significant architectural challenge. To overcome this, our solution is designed to work with a third-party webhook plugin installed within Redmine. This enables Redmine to participate in the event-driven ecosystem. As a crucial fallback and for data reconciliation, the architecture also incorporates a supplementary, scheduled polling mechanism. This poller periodically queries the Redmine API to detect any changes that might have been missed due to transient webhook delivery failures, ensuring long-term data consistency. All incoming events, whether from webhooks or polling, are not processed synchronously; instead, they are placed onto a durable job queue, creating a resilient, asynchronous processing pipeline that can handle high-volume workloads and recover gracefully from transient failures.

In contrast to the black-box nature of a commercial solution like OpsHub, our custom Laravel application provides complete transparency and control over the integration logic. While OpsHub offers a no-code graphical user interface for configuring mappings and rules, our solution externalizes this configuration into a dedicated database schema and environment files, managed through a custom web interface. This provides a high degree of flexibility, allowing developers to implement complex data transformations and custom business logic that may not be possible with a pre-packaged tool. The Laravel application is responsible for the entire data lifecycle: receiving events, validating payloads, transforming data according to user-defined mappings (for statuses, trackers, users, and custom fields), handling complex data types like rich text and attachments, and executing API calls to the target system. It also includes a persistent state management layer to track the relationships between Redmine and Jira entities, which is essential for routing updates correctly and for implementing a conflict resolution strategy. This API-based, service-oriented architecture provides a powerful and adaptable framework for bridging the operational gap between development and quality assurance teams.

## IMPLEMENTATION STEPS

The successful deployment of the Redmine Jira Integration solution requires a sequential and meticulous setup process. This process covers the installation of the core Laravel application, the configuration of secure connections to both Redmine and Jira APIs, the establishment of webhook communication channels, and the detailed definition of synchronization rules through the application's user interface. Each step is critical for ensuring the reliability and accuracy of the data synchronization.

The initial phase involves setting up the Laravel application environment. This begins with cloning the application repository and installing its dependencies using standard PHP and JavaScript package managers. You will execute `composer install` to fetch all required PHP libraries and `npm install` to install the necessary JavaScript dependencies for the frontend. Following dependency installation, the environment must be configured by creating a `.env` file from the provided example. This file is the central location for all critical configuration parameters, including application settings, database connection details, and security secrets. A unique application key must be generated using the `php artisan key:generate` command. For the database, the application supports SQLite, MySQL, and PostgreSQL. After configuring the database credentials in the `.env` file, you must run the database migrations with `php artisan migrate` to create the necessary tables for storing connections, mappings, and synchronization logs. Finally, the frontend assets must be compiled for production using `npm run build`. With the application installed and configured, it can be served locally using `php artisan serve`, and the essential asynchronous job queue can be started with `php artisan queue:work`.

Once the application is running, the next step is to establish secure connections to the Redmine and Jira instances. This is managed within the application's web interface, typically under a "Connections" section. For Redmine, you will need to create a new connection by providing a descriptive name, the base URL of your Redmine instance (e.g., `https://redmine.example.com`), and a valid API key from a Redmine user account that has the necessary permissions. For Jira, the process is similar, requiring a connection name, the base URL of your Jira Cloud instance (e.g., `https://yourcompany.atlassian.net`), the email address of the integration user, and an API token generated from that user's Atlassian account settings. The application provides a "Test Connection" feature to verify that the provided credentials are correct and that the integration service can successfully communicate with both APIs.

With API connections established, you must configure webhooks in both Redmine and Jira to enable real-time event notifications. The Laravel application exposes two dedicated endpoints for this purpose: `/webhooks/redmine` and `/webhooks/jira`. In Jira's system settings, you will create a new webhook, providing the full URL to the Jira endpoint and selecting the events to monitor, such as "Issue created" and "Issue updated." For enhanced security, you should configure a secret token in the Jira webhook settings, using the `JIRA_WEBHOOK_SECRET` value from your `.env` file for signature verification. For Redmine, since it lacks native webhooks, you must first install a suitable third-party plugin. Once installed, you will configure it to send POST requests to the application's Redmine webhook URL for issue creation and update events, similarly securing it with the `REDMINE_WEBHOOK_SECRET`.

The final and most detailed phase of the implementation is the configuration of synchronization logic within the application's UI. This involves creating comprehensive field mappings to translate data between the two systems. You must define mappings for Redmine trackers to Jira issue types, Redmine statuses to their corresponding Jira statuses, and priorities. A critical task is user mapping, where you associate Redmine user accounts with Jira user accounts to ensure that assignees and reporters are synchronized correctly. You will also configure mappings for any custom fields that need to be synchronized. After defining the global field mappings, you will create project-specific mappings. For each pair of projects you wish to integrate, you will specify the source and target connections and projects, and define the synchronization direction (bi-directional, Redmine-to-Jira, or Jira-to-Redmine). Once a project mapping is activated, the integration is live. The application's dashboard provides tools for monitoring the status of sync jobs, viewing activity logs, and troubleshooting any failed synchronizations.

## TECHNICAL REQUIREMENTS

To ensure a successful and stable deployment, a specific set of technical prerequisites must be met across the server environment, the connected applications (Redmine and Jira), and the network infrastructure. Adherence to these requirements is essential for the performance, security, and reliability of the integration.

The server hosting the redmine-jira-integration application must be provisioned with a modern software stack. The required version of PHP is 8.2 or higher, and Composer is necessary for managing PHP dependencies. For compiling the frontend assets, Node.js and pnpm are required. The application is compatible with several database systems, including SQLite for development and testing, and more robust options like MySQL or PostgreSQL for production environments. For optimal performance of the asynchronous job queue in a production setting, Redis is highly recommended over the default database queue driver. The web server can be Apache or Nginx, and it must be configured to serve the Laravel application from its `/public` directory. For production deployments, a process manager such as Supervisor is essential for ensuring that the queue worker processes remain active and are automatically restarted in case of failure.

API credentials and permissions for both Redmine and Jira are fundamental to the integration's operation. For Redmine, the REST API must be globally enabled in the administration settings. The integration requires an API key from a user account that possesses sufficient permissions to view projects and users, and to create and update issues within the target projects. Administrative access may be required if the integration needs to manage custom field definitions programmatically. For Jira Cloud, the integration authenticates using an API token, not a password. This token must be generated from the Atlassian account of a user who has permissions to browse projects, create, edit, and transition issues, and manage comments and attachments in the projects being synchronized. The authentication method is HTTP Basic Authentication, where the username is the user's email address and the password is the API token.

Network and security configurations are critical for enabling communication and protecting the integration. The server hosting the redmine-jira-integration application must have a publicly accessible IP address and be configured with HTTPS using a valid SSL certificate. This is a mandatory requirement for production, as it encrypts all data in transit, including sensitive API credentials and issue data. The firewall must be configured to allow inbound traffic on port 443 to the application's webhook endpoints (`/webhooks/redmine` and `/webhooks/jira`). These endpoints must be reachable from Atlassian's cloud servers and your Redmine server. To prevent unauthorized requests, the integration relies on webhook signature verification. This requires generating strong, random secret strings in the application's `.env` file and configuring those same secrets in the webhook settings within Jira and the Redmine webhook plugin. This ensures that the application only processes requests that are verifiably from the correct source.

## DATA MAPPING STRATEGY

A robust and flexible data mapping strategy is the cornerstone of a successful bi-directional integration, ensuring that information remains consistent and contextually accurate as it moves between Redmine and Jira. The strategy must account for differences in data models, workflows, and content formats between the two platforms. The custom Laravel application provides a dedicated interface for configuring these complex mappings.

The most fundamental mapping is between Redmine's "Trackers" and Jira's "Issue Types." This mapping defines the basic classification of work items. For example, a "Bug" tracker in Redmine would typically be mapped to a "Bug" issue type in Jira, while a "Feature" tracker might be mapped to a "Story" or "New Feature" in Jira. This configuration is critical because the available fields and workflows in Jira are often dependent on the issue type. A closely related and equally important task is mapping the issue statuses. Each project in Redmine and Jira has its own workflow, and the status names rarely align perfectly. The mapping engine must allow for a many-to-one or one-to-many relationship, such as mapping both Redmine's "Resolved" and "Closed" statuses to Jira's single "Done" status. This requires a careful analysis of both teams' workflows to ensure that status transitions are logical and do not violate the workflow rules of the target system. Similarly, priority levels must be mapped, often requiring a normalization of different scales (e.g., Redmine's "Low," "Normal," "High," "Urgent" to Jira's "Lowest," "Low," "Medium," "High," "Highest").

Handling custom fields and user assignments requires a more dynamic mapping approach. The integration must be able to map custom fields between the two systems, even when their types differ. For instance, a text-based custom field in Redmine might need to be mapped to a select-list custom field in Jira. This requires not only mapping the fields themselves but also their potential values, and defining a default value or an error-handling procedure for cases where a value from the source system does not exist in the target system. User mapping is another critical area. Since user accounts are separate in each system, the integration must maintain a persistent lookup table that associates a Redmine user with their corresponding Jira account. This is essential for correctly synchronizing the "Assignee" and "Reporter" fields, as well as for attributing comments to the correct user.

The strategy for handling complex content, such as comments, attachments, and rich text, must address significant technical differences between the platforms. Redmine typically uses Textile or Markdown for formatting in description and comment fields. In contrast, Jira Cloud uses the Atlassian Document Format (ADF), a structured JSON format that supports complex layouts, mentions, and embedded media. The integration's data transformation pipeline must be capable of converting between these formats. This involves parsing the source content and rendering it into the target format, a process that may involve compromises, such as converting unsupported ADF elements into plain text or links when synchronizing to Redmine. Attachment handling also differs. In Redmine, attachments are uploaded in a two-step process involving a temporary token, whereas in Jira, they are attached directly to an issue. The integration logic must abstract these differences and maintain a state to prevent duplicate uploads of the same attachment.

Finally, a clear conflict resolution strategy is necessary to maintain data integrity. In a bi-directional synchronization, conflicts can occur if an issue is updated in both systems simultaneously. The default strategy implemented in this solution is **last-write-wins**, where the most recent update, based on its timestamp, overwrites the older one. While simple, this can lead to data loss. Therefore, the system is designed to log all conflict events in detail. This allows administrators to review instances where data was overwritten and perform manual reconciliation if necessary. This approach provides a balance between automated processing and the safety net of human oversight for critical data conflicts.

## USE CASE IMPLEMENTATION

To illustrate the practical application of this integration, this section provides a detailed walkthrough of a primary use case: a workflow where a Quality Assurance (QA) team logs defects in Redmine, and a Development team works on those defects in Jira. The goal is to maintain seamless, real-time synchronization between the two systems, providing both teams with a consistent view of the defect's status and history, thereby ensuring traceability for audit purposes.

The initial configuration for this use case is performed within the redmine-jira-integration application's web interface. First, an administrator creates a new project mapping. The source is configured to be the "QA Bug Reports" project in the Redmine connection, and the target is the "DEV" project in the Jira connection. The synchronization direction is set to "Bi-directional" to allow updates to flow freely between the two teams. Next, the administrator configures the necessary field mappings. The Redmine "Bug" tracker is mapped to the Jira "Bug" issue type. The status workflow is carefully mapped to reflect the teams' processes: Redmine's "New" status is mapped to Jira's "To Do," Redmine's "In Progress" is mapped to Jira's "In Progress," and Redmine's "Resolved" is mapped to Jira's "Done." User mappings are also configured to associate each QA team member's Redmine account with their Jira account, and likewise for the development team.

The workflow begins when a QA engineer discovers a defect and creates a new issue in the "QA Bug Reports" project in Redmine. They set the tracker to "Bug," assign a priority, write a detailed description with steps to reproduce, and attach relevant log files or screenshots. Upon saving the issue, the Redmine webhook plugin immediately sends a notification to the redmine-jira-integration service. The service receives the payload, validates it, and places a job on the queue for processing. The queue worker picks up the job, retrieves the full issue details from the Redmine API, and uses the configured mappings to transform the data into the format required by the Jira API. It converts the Redmine user to the corresponding Jira user, maps the status and priority, and translates the Textile-formatted description into Jira's Atlassian Document Format. The service then makes an API call to Jira to create a new issue of type "Bug" in the "DEV" project. The attachments are also downloaded from Redmine and uploaded to the newly created Jira issue. Finally, the integration service stores the mapping between the new Redmine issue ID and the Jira issue key in its database for future updates.

The development team is notified of the new bug in their Jira project. A developer assigns the issue to themselves and transitions its status from "To Do" to "In Progress." This action triggers a Jira webhook, which notifies the integration service of the update. The service processes this event, looks up the corresponding Redmine issue ID from its database, and makes an API call to update the Redmine issue. The assignee is updated to the developer, and the status is changed to "In Progress," reflecting the change made in Jira. Any comments added by the developer in Jira are also synchronized back to the Redmine issue as notes. Once the developer has fixed the bug and marks the Jira issue as "Done," another webhook is triggered. The integration service updates the Redmine issue's status to "Resolved," signaling to the QA team that the defect is ready for verification. This bi-directional flow ensures that both systems remain perfectly in sync throughout the defect lifecycle, eliminating manual data entry and providing a single source of truth for all stakeholders. Common troubleshooting issues in this workflow, such as a webhook failing to deliver, are mitigated by the system's retry logic and the periodic polling mechanism, which would eventually catch and synchronize the missed update.

## ALTERNATIVE SOLUTIONS

When considering a Redmine Jira Integration, organizations have several strategic options, each with distinct advantages, limitations, and cost implications. These can be broadly categorized into commercial off-the-shelf solutions, open-source alternatives, and the custom-built Laravel solution detailed in this guide. A thorough comparison provides the context needed to make an informed decision based on an organization's specific technical capabilities, budget, and business requirements.

The primary commercial solution in this space is **OpsHub Integration Manager (OIM)**. OIM is an enterprise-grade platform that offers a polished, no-code user interface for configuring complex, bi-directional synchronizations. Its main advantages are its reliability, dedicated customer support, and extensive feature set, which includes advanced conflict resolution, high-fidelity data migration that preserves historical context, and broad compatibility with numerous other ALM and DevOps tools. However, these benefits come at a significant cost, with licensing fees that can be prohibitive for smaller organizations. Furthermore, relying on a commercial tool can lead to vendor lock-in, and its closed-source nature limits the ability to implement highly specific or custom business logic that falls outside the platform's capabilities. OIM is best suited for large enterprises that require a fully supported, turnkey solution and prioritize ease of administration over customizability and cost.

On the other end of the spectrum are **open-source alternatives**. The landscape for dedicated, open-source Redmine-Jira synchronization tools is sparse and fragmented. While some scripts and small projects exist on platforms like GitHub, they are often unmaintained, lack comprehensive features, and do not provide the enterprise-grade reliability needed for mission-critical workflows. They typically lack a user interface for configuration, robust error handling, asynchronous processing queues, and sophisticated conflict resolution. Implementing such a tool often requires significant development effort to adapt it to a specific environment and to build in the necessary resilience. Therefore, open-source solutions are generally only suitable for very simple, unidirectional data syncing, or as a foundational starting point for a company that intends to build its own custom solution anyway.

The **custom Laravel solution** described in this guide represents a strategic middle ground. Its primary advantage is the complete control and flexibility it offers. It can be tailored to meet the exact workflow and data transformation needs of an organization, without the limitations of a commercial product. The total cost of ownership can be significantly lower than a commercial license, as it is primarily based on internal development and hosting costs. However, this approach carries the responsibility of ongoing maintenance, including updates, bug fixes, and security hardening. It requires an in-house team with expertise in PHP, Laravel, and system administration. This solution is ideal for organizations that have unique integration requirements, possess the necessary technical talent, and prefer to invest in a custom-built asset that they fully own and control, rather than paying recurring licensing fees for a commercial product. The cost-benefit analysis ultimately hinges on an organization's scale, budget, and technical maturity: large, risk-averse enterprises may favor the support and stability of OpsHub; small teams with simple needs might experiment with open-source scripts; and tech-forward companies with specific needs will find the most value in a custom-built solution.